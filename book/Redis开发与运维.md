# 基本

- [P19 图2-2] 美中数据结构, 对应多种内部编码: 针对于不同情况 (键的多少, 值的大小等), 在效率和内存用量之间取得平衡
- [P70] 使用keys列举所有键, 会发生阻塞 -> 改用scan游标进行读取
- [P86] 对于访问redis的操作, 解决网络延迟的方法: 
  - 批处理: 批量命令, 批量接受结果
  - 流水线(pipeline): 批量命令, 顺序接受结果
- [P102] Redis提供HyperLogLog结构, HyperLogLog是一种基数算法, 能在极小内存开销下完成独立计数, 但结果存在少量偏差
- [P106] Redis提供了发布/订阅模型
- [P160] AOF存储格式是流失变更记录, 定期需要重写(将增量记录重写为镜像), 以收缩空间. 
  - 重写期间, 使用变更缓存以接续业务
  - 重写使用子线程, 父子线程间由Linux提供的copy-on-write来减小内存开销
  - 其阻塞Redis业务的可能性: 
    - Fork时, 需要复制线程页表, 造成阻塞
    - AOF刷盘造成阻塞

# 复制

- [P175] 复制的三要素
  - 标识ID, 识别数据节点
  - 对齐点位
  - 数据缓冲, relay log
- Redis的主从复制: 全量+增量

# 内存

- [P201] Redis的内存消耗模型
  - 自身内存
  - 对象内存: 用于存储KV
  - 缓冲内存: 用于主从复制的buffer等
  - 内存碎片
- [P205] 设计: 对过期键的删除维护:
  - 由于维护成本考虑, 采用 惰性删除 + 定时的小批次删除
- [P211] 内存优化: 共享0-9999整数对象, 但该策略与LRU冲突
- [P215] 内存优化: 字符串采用预分配内存, 且不主动回收
  - 对于JSON等数据类型, 使用结构化数据结构优于字符串: 防止频繁变更造成的字符串内存碎片

# 高可用

- Redis Sentinel: 相当于一个"能做一致性决策的决策集群", 多个Sentinel节点认为需要切换时, 集群会裁决出一个负责人, 完成切换动作. 
- 客户端向Sentinel集群订阅 切换变更的信息
- [P255] Sentinel将Sentinel集群的元信息存储在受管的Redis数据节点中 ??

# 分布式
- [P276] 传统一致性Hash分区的问题, 主要出现在增减节点上: 
  1. 增减节点时, 部分数据无法命中, 需要手工处理
  2. 使用少量节点时, 增减节点影响的数据较多
  3. 需要增加成倍节点, 才能保持数据均衡
- 为解决上述问题, Redis使用 虚拟槽+一致性哈希
- [P278] 分布式的功能限制:
  - 批量类操作, 会限制在分片内完成: 批量/流水线/事务
  - 不支持多个数据库空间 (多空间功能属于陈旧功能)
  - 无法进行级联复制 (??)
- 分布式集群的高可用 
  - [P290] 使用Gossip协议, 如何选择Gossip的一次通讯节点的平衡: 
    - 一次节点数过多, 会影响带宽
    - 一次节点数过少, 会影响征集群达成一致的效率
  - [P328] 分布式集群的高可用维护, 使用Gossip协议传递某节点的视角. 当多数节点报告A节点离线时, 才可判故障, 发起选举.
  - [P329] 高可用选举时, 各个Slave会根据自己的数据偏移量, 延迟不同时间开始发起选举 (偏移量越大 -> 数据越多 -> 主从延迟越小 -> 该slave节点应成为新的master -> 应尽早发起选举)
  - [P334]集群的故障转移时间的计算
- 如何访问数据
  - [P306] 客户端访问分片数据的方法: 传统客户端: 如目标数据不在分片内, 回复MOVE, 客户端响应MOVE将访问转到目标分片
  - [P308] 分片Hash, 可指定对Key的某一部分进行Hash, 以按照业务含义进行分片
  - [P309] Smart客户端: 未解决传统客户端的多次I/O问题, 可由客户端对数据的分布关系进行计算 (相当于 建立路由缓存)
    - [P318] 对于正在进行迁移的数据槽slot, 可用ASK重定向, 与MOVE的区别是 ASK不会更新smart客户端的路由缓存
- [P338] 发布/订阅 机制, 在集群模式下有广播风暴的风险, 不建议使用.

# 应用设计

- [P350] 缓存穿透问题 (查找不存在的数据, 使得需要访问存储)
  - 可缓存空对象 -> 对导致空间要求大
  - 布隆过滤器, 相当于用低成本且存在偏差的方式进行粗晒, 即缓存空对象
- [P363] 缓存过期时的雪崩效应
  - 可用锁控制 对 缓存某个键的访问并发, 减少雪崩
  - 永不过期, 不使用Redis的硬过期, 而使用软过期策略
