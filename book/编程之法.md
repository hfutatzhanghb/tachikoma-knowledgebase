# 1.1 字符串的旋转
思路: 先关注大顺序, 再看小顺序
解法: 一次反转调整大小顺序, 再通过一次反转将小顺序置回

# 1.2 字符串的包含
知识: 建立Hash表的方法: 1. 素数相乘 2. 位运算

# 1.3 字符串的全排列
知识: 生成全排列的方法 [10]: (以21543举例)
    1. 找到排列中最后一个升序的首位值x, 位置为i (x=1, i=1, 15为最后一个升序, 1是其首位)
    2. 找到排列中第i位右边最后一个比ai大的位置j, 值为y (y=3, j=4, 3是最后一个比1大的数字)
    3. 交换x和y (变为23541)
    4. 第i+1位到最后的部分反转 (变为23145)

# 1.6 最长回文子串
知识: 
    1. 通过加入特殊字符, 将奇偶判断简化为只有奇判断
    2. Manacher算法, 比较复杂, 思路是通过数学性质, 调整穷举回文长度时的霞姐, 减少穷举量
    
# 2.1 寻找最小的k个数
知识: 类似于快排算法, 寻找某个主元在数组中的排位, 将数组二分后, 对子数组再进行递归搜索

# 2.7 荷兰国旗
思路: 三指针快排

# 2.9 完美洗牌算法
算法过于复杂, 不做深究
思路: 研究期望状态和初始状态的数学关系, 找到解法

# 3.1 统计出现次数最多的数据
知识: 红黑树为保持平衡, 所拥有的特性: 
    1. 每个节点要么是红的, 要么是黑的
    2. 根节点是黑的
    3. 每个叶子节点都是黑的
    4. 如果一个节点是红的, 那么它的两个孩子都是黑的
    5. 对于任意节点, 其到叶节点的每条路径都包含相同数目的黑色节点
    
# 3.2 上亿行数据的快速查询
知识: B树与红黑树的不同: 
    1. B树的节点可以有许多个孩子
    2. 红黑树的读取与查找的代价相同. 由于考虑到外村, 读取成本会远大于内存查找的成本, B树是为了这种情况而设计的
    3. 红黑树通过旋转调整, 维护平衡, 允许左右子树有不同层次; B树通过分裂/升降调整整树进行高度调整, 子树的高度都相同
知识: B+树, 将信息下放到叶子节点, 使得中间节点仅作为索引

# 3.3 最近公共祖先问题
知识: RMQ问题 (range minimum query, 求某段区间的极值), 求解的核心在于 关注于多次反复求解时的性能 (单次求解的性能无法提升), 思路是用区间统计值代替具体值: 
    1. 动态规划, 即按1分区
    2. 分为 根号n 个子区
    3. 按2^n进行分区
    
知识: 求解最近公共祖先(LCA)问题, 解法:
    1. 对于有序树, 可判断A和B是否在同一子树, 递归求解
    2. 对于无序树, 只能降低多次查询的开销.
    
有趣的思路: 深度优先遍历树的路径上, LCA(A,B) 是A->B的路径上 层次最低的节点, 从而就转化成了RMQ问题 (通过遍历路径的特性, 描述LCA特性, 将问题进行转化)

# 4.2 行列递增矩阵的查找

解法1: 由行列特性, 得到稳定的性质 (左上角小于X, 右下角大于X), 以此进行分治
解法2: 使得决策唯一. 若从左上角出发, 则右侧和下侧都比当前数大, 难以决策. 而从右上角出发, 则下侧比当前数大, 左侧比当前数小, 决策可唯一.

# 4.3 出现次数超过一半的数

思路: 过半问题, 可让元素进行相互抵消, 直到有剩余 (核心是减少状态, 将出现次数转化为01状态)

# 4.4 字符串的查找

思路: KMP算法, 核心是 观察遍历过程中的重复开销, 通过预处理降低开销

# 5.3 格子取数问题

思路: 由于只能向右或向下走, 相同步数到达的格子形成了一个阶段, 可进行动态规划

# 6.7 布隆过滤器

思路: 用多个散列函数, 将元素映射到同一个散列空间, 存在误判率, 用以换取存储空间的开销




