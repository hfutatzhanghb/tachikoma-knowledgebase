## 数据异常现象
如果没有并发控制, 将出现以下数据异常
### 脏读 (Dirty Read)

| 时间轴 | 事务1 | 事务2 |
| --- | --- | --- |
| 0  | Write(row)  | - |
| 1  | -  | Read(row) |
| 2  | Rollback  | - |

### 不可重复读 (Fuzzy Read)

| 时间轴 | 事务1 | 事务2 |
| --- | --- | --- |
| 0  | Read(row)  | - |
| 1  | -  | Update/Delete(row) |
| 2  | -  | Commit |
| 3  | Read(row)  | - |

### 幻读 (Phantom)

| 时间轴 | 事务1 | 事务2 |
| --- | --- | --- |
| 0  | Read(rows) WHERE \<cond\> | - |
| 1  | -  | Insert/Update with \<cond\> |
| 2  | Read(rows) WHERE \<cond\>  | - |

### 脏写 (Dirty Write)

| 时间轴 | 事务1 | 事务2 |
| --- | --- | --- |
| 0  | Write(row) | - |
| 1  | -  | Write(row) |
| 2  | -  | Commit |
| 3  | Rollback | - |

步骤3将回滚步骤1的更新

### 更新丢失 (Lost Update)

| 时间轴 | 事务1 | 事务2 |
| --- | --- | --- |
| 0  | Read(row) | - |
| 1  | -  | Write(row) |
| 2  | Write(row) | - |
| 3  | Commit | - |

步骤2的更新将覆盖步骤1的更新

### 写偏序 (Write Skew)

即使有ACID和MVCC, 仍可能存在的数据异常

| 时间轴 | 事务1 | 事务2 |
| --- | --- | --- |
| 0  | Select Count(*) WHERE record.a = 1| - |
| 1  | -  | Select Count(*) |
| 2  | if Count(*) > 2 then Update record[1].a = 0 | - |
| 3  | - | if Count(*) > 2 then Update record[2].a = 0 |
| 4  | Commit | - |
| 5  | - | Commit | 

执行结果与串行化不同, record[1]和[2]都会被更新.

问题在于`if-then`条件依赖于`Count(*)`, 而`Count(*)`操作并不锁住record的所有记录. 即使用某个前提条件时, 并没有对前提条件的相关数据上锁(以阻止条件改变).

### 读偏序 (Read Skew)

| 时间轴 | 事务1 | 事务2 |
| --- | --- | --- |
| 0  | Read(x) | - |
| 1  | -  | Write(x), Write(y) |
| 2  | -  | Commit |
| 3  | Read(y) | - |

与写偏序类似, 步骤0并没有将 隐含的前提条件(x与y是一致的) 锁起来, 使得事务2可以改变这个前提条件

### 数据异常与隔离级别关系表

[Table 4: Isolation Types Characterized by Possible Anomalies Allowed](https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr-95-51.pdf)
