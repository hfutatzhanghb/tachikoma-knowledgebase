# 语言源码讨论框架
- 引导器
- 初始化: 讨论有几个模块涉及初始化过程
- 内存分配
- 垃圾回收
- 并发调度
  - 系统调用
- 语言特性
  - channel
  - defer
  - ...

# 讨论方法
- 用go build参数关闭编译器优化, 用gdb进行调试
- `go tool objdump`查看汇编代码

# 语言基础的遗漏点
- `var a []int` 与 `b := []int{}`的区别: a指向nil, Data区不分配地址. [103, 关注其证明方法]
- Go数组是值类型 [99], 字典是指针类型 [116]
- 反射获取对象的方法集的代码 [135]
- 用gdb进行interface相关的调试 [146]
- 接口判空的条件是: itab和data都为空. 使用error接口时, 若返回类型是具体类型, 则会返回带啦诶性的nil, 使得`nil == error`判断失败 [149]
- 技巧: 让匿名函数"自动"实现某接口 [152]
- internal包的代码仅能被父级代码目录访问到 [196]
- 反射中的Kind与Type的区别: Kind是底层类型, Type是静态(定义的)类型 [200]
- `MakeFunc`构造类似泛型的函数 [213]

# 内存分配

## 层次结构

- OS: 提供空间
  - 虚地址空间: spans (span指针数组) + bitmap (GC标记维度) + arena (用户内存区域) [259]
- heap: 无规格. 必要时向OS申请/归还内存
- central: 按span规格进行管理
  - empty和nonempty两个数组, central分配资源时, 优先取用已用(但没用满的)资源(nonempty) [273]
- cache: 与P绑定, 为工作线程私有, 可无锁使用. 相当于central的缓存
- span: 内存块
- object: 具体对象

## 内存分配 [267]
- 微小对象: 从cache中的tiny_object直接分配
- 普通小对象: 从cache中对应规格的span中分配
- 大对象: 从heap中直接分配

## 内存回收 [279]
- 内存回收以span为单位. 用bitmap中的标记, 逐步将object回收至span, 再将span回收至central 

## 内存释放 [283]
- 监控任务sysmon, 负责扫描heap中的闲置span, 将闲置过长的span释放给OS

## 管理对象
与用户对象不同, 管理对象大小固定且生存周期长, 管理对象的内存分配由单独的分配器机制完成 [285]

# GC

## 概述
- GC的特征 [291]
  - 非分代 (本书未讨论)
  - 非紧缩 (本书未讨论)
  - 写屏障
  - 并发标记清理
- GC的核心思路 [291]
  - 抑制堆增长
  - 充分利用CPU资源
  
## 流程
- 触发GC的条件 [295]
  - `heap_live (活跃对象数) > memstat.next_gc (自适应的gc阈值)` 
- STW
  - 设置全局状态
  - 启用写屏障 (获取之后的内存修改)
- 第一轮扫描 (并发扫描捕获的灰色对象)
- 第二轮扫描 (扫描新分配白色对象) [???]
- STW
  - 关闭写屏障
  - 开始清理

# 未尝试过的内容
- sync.Cond
- go generate [239]
- `-gcflags '-m'` 可查看编译优化信息
